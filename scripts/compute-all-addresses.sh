#!/bin/bash
# Compute addresses for all units from example-units-input.yml using UnitHelper
# Generates _data/example-units.yml with addresses for Jekyll
# Usage: ./compute-all-addresses.sh [rpc-url]

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INPUT_FILE="$SCRIPT_DIR/../_data/example-units-input.yml"
OUTPUT_FILE="$SCRIPT_DIR/../_data/example-units.yml"
RPC_URL="${1:-https://ethereum.publicnode.com}"

if [ ! -f "$INPUT_FILE" ]; then
    echo "Error: Input file not found: $INPUT_FILE" >&2
    exit 1
fi

# Check for yq and jq
if ! command -v yq &> /dev/null; then
    echo "Error: yq is required but not installed" >&2
    echo "Install with: brew install yq (macOS) or snap install yq (Linux)" >&2
    exit 1
fi

if ! command -v jq &> /dev/null; then
    echo "Error: jq is required but not installed" >&2
    echo "Install with: brew install jq" >&2
    exit 1
fi

# Generate .env if it doesn't exist
if [ ! -f "$SCRIPT_DIR/.env" ]; then
    echo "Generating .env file..."
    "$SCRIPT_DIR/generate-env.sh"
fi

# Source the .env file
source "$SCRIPT_DIR/.env"

echo "Computing addresses for units from: $INPUT_FILE"
echo "Uniteum: $ONE"
echo "UnitHelper: $HELPER"
echo "RPC: $RPC_URL"
echo "Output: $OUTPUT_FILE"
echo ""

# Extract all symbols from input file and build JSON array using yq
unit_count=$(yq eval '.units | length' "$INPUT_FILE")
symbols_json=$(yq eval '.units[].symbol' "$INPUT_FILE" | jq -R . | jq -s -c .)

echo "Found $unit_count units to process"
echo ""

echo "Calling UnitHelper.product() to batch-predict addresses..."

# Call UnitHelper.product() to get all addresses and canonical forms in one call
# Returns: (address[] units, string[] symbols)
result=$(cast call "$HELPER" "product(address,string[])(address[],string[])" "$ONE" "$symbols_json" --rpc-url "$RPC_URL" 2>&1)

if [ $? -ne 0 ]; then
    echo "Error: Failed to call UnitHelper.product()" >&2
    echo "$result" >&2
    exit 1
fi

# Parse the result - cast returns two arrays on separate lines
# Line 1: [addr1, addr2, ...]
# Line 2: ["sym1", "sym2", ...]

# Extract addresses array (first line)
addresses_raw=$(echo "$result" | head -1)
# Extract symbols array (second line)
symbols_raw=$(echo "$result" | tail -1)

# Parse addresses - remove brackets and commas, split on spaces
addresses_clean=$(echo "$addresses_raw" | tr -d '[],' | xargs)
IFS=' ' read -r -a addresses_array <<< "$addresses_clean"

# Parse canonical symbols - remove brackets, quotes, and commas
canonicals_clean=$(echo "$symbols_raw" | tr -d '[]",' | xargs)
IFS=' ' read -r -a canonicals_array <<< "$canonicals_clean"

echo "Successfully retrieved ${#addresses_array[@]} addresses and ${#canonicals_array[@]} symbols"
echo ""

# Start building output YAML
cat > "$OUTPUT_FILE" << 'EOF'
# Example Units with Computed Addresses
# Generated by scripts/compute-all-addresses.sh using UnitHelper
# DO NOT EDIT MANUALLY - Edit _data/example-units-input.yml instead

units:
EOF

# Write each unit to output file
for ((i=0; i<unit_count; i++)); do
    symbol=$(yq eval ".units[$i].symbol" "$INPUT_FILE")
    description=$(yq eval ".units[$i].description" "$INPUT_FILE")
    canonical="${canonicals_array[$i]}"
    address="${addresses_array[$i]}"

    echo "  ✓ $symbol → $canonical ($address)"

    # Append to output file (no escaping needed for : operator)
    cat >> "$OUTPUT_FILE" << EOF
  - symbol: "$symbol"
    canonical: "$canonical"
    address: "$address"
    one: "$ONE"
    description: "$description"

EOF
done

echo ""
echo "✅ Address computation complete!"
echo "Output written to: $OUTPUT_FILE"
echo "Unit count: $unit_count"

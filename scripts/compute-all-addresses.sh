#!/bin/bash
# Compute addresses for all units from example-units-input.yml using UnitHelper
# Generates _data/example-units.yml with addresses for Jekyll
# Usage: ./compute-all-addresses.sh [rpc-url]

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INPUT_FILE="$SCRIPT_DIR/../_data/example-units-input.yml"
OUTPUT_FILE="$SCRIPT_DIR/../_data/example-units.yml"
RPC_URL="${1:-https://ethereum.publicnode.com}"

if [ ! -f "$INPUT_FILE" ]; then
    echo "Error: Input file not found: $INPUT_FILE" >&2
    exit 1
fi

# Check for yq and jq
if ! command -v yq &> /dev/null; then
    echo "Error: yq is required but not installed" >&2
    echo "Install with: brew install yq (macOS) or snap install yq (Linux)" >&2
    exit 1
fi

if ! command -v jq &> /dev/null; then
    echo "Error: jq is required but not installed" >&2
    echo "Install with: brew install jq" >&2
    exit 1
fi

# Generate .env if it doesn't exist
if [ ! -f "$SCRIPT_DIR/.env" ]; then
    echo "Generating .env file..."
    "$SCRIPT_DIR/generate-env.sh"
fi

# Source the .env file
source "$SCRIPT_DIR/.env"

echo "Computing addresses for units from: $INPUT_FILE"
echo "Uniteum: $ONE"
echo "UnitHelper: $HELPER"
echo "RPC: $RPC_URL"
echo "Output: $OUTPUT_FILE"
echo ""

# Extract all symbols from input file and build JSON array using yq
unit_count=$(yq eval '.units | length' "$INPUT_FILE")
symbols_json=$(yq eval '.units[].symbol' "$INPUT_FILE" | jq -R . | jq -s -c .)

echo "Found $unit_count units to process"
echo ""

echo "Calling UnitHelper.product() to batch-predict addresses..."

# Call UnitHelper.product() to get all addresses and canonical forms in one call
# Returns: (address[] units, string[] symbols)
result=$(cast call "$HELPER" "product(address,string[])(address[],string[])" "$ONE" "$symbols_json" --rpc-url "$RPC_URL" 2>&1)

if [ $? -ne 0 ]; then
    echo "Error: Failed to call UnitHelper.product()" >&2
    echo "$result" >&2
    exit 1
fi

# Parse the result - cast returns two arrays on separate lines
# Line 1: [addr1, addr2, ...]
# Line 2: ["sym1", "sym2", ...]
addresses_raw=$(echo "$result" | head -1)
symbols_raw=$(echo "$result" | tail -1)

# Convert cast output to JSON arrays
addresses_json=$(echo "$addresses_raw" | tr -d ' ' | sed 's/^\[/["/' | sed 's/,/","/g' | sed 's/\]$/"]/')
canonicals_json=$(echo "$symbols_raw" | tr -d ' ')

echo "Successfully retrieved addresses and symbols"
echo ""

# Merge everything using jq: combine input YAML with addresses and canonicals
yq eval -o=json "$INPUT_FILE" | \
jq --argjson addresses "$addresses_json" \
   --argjson canonicals "$canonicals_json" \
   --arg one "$ONE" \
   '{units: [.units | to_entries[] | .value + {
     canonical: $canonicals[.key],
     address: $addresses[.key],
     one: $one
   }]}' | \
yq eval -P - | \
yq eval '(.units[].address, .units[].one) style="double"' - | \
sed '1i# Example Units with Computed Addresses\n# Generated by scripts/compute-all-addresses.sh using UnitHelper\n# DO NOT EDIT MANUALLY - Edit _data/example-units-input.yml instead\n' > "$OUTPUT_FILE"

# Print summary
for ((i=0; i<unit_count; i++)); do
    symbol=$(yq eval ".units[$i].symbol" "$INPUT_FILE")
    canonical=$(echo "$canonicals_json" | jq -r ".[$i]")
    address=$(echo "$addresses_json" | jq -r ".[$i]")
    echo "  ✓ $symbol → $canonical ($address)"
done

echo ""
echo "✅ Address computation complete!"
echo "Output written to: $OUTPUT_FILE"
echo "Unit count: $unit_count"
